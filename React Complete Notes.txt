React Complete Notes

What Are Content Delivery Networks?
A content delivery network (CDN) is a geographically distributed group of servers that caches content close to end users. A CDN allows for the quick transfer of assets needed for loading Internet content, including HTML pages, JavaScript files, stylesheets, images, and videos.
The popularity of CDN services continues to grow, and today the majority of web traffic is served through CDNs, including traffic from major sites like Facebook, Netflix, and Amazon.
A properly configured CDN may also help protect websites against some common malicious attacks, such as Distributed Denial of Service (DDOS) attacks.
Is a CDN the same as a web host?
While a CDN does not host content and can’t replace the need for proper web hosting, it does help cache content at the network edge, which improves website performance. Many websites struggle to have their performance needs met by traditional hosting services, which is why they opt for CDNs.
By utilizing caching to reduce hosting bandwidth, helping to prevent interruptions in service, and improving security, CDNs are a popular choice to relieve some of the major pain points that come with traditional web hosting.

<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
Above is the core react library which contains core react code.
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
Above is the react-dom library which has the document object manipulation code which is used to modify the DOM.
Why separate?
React itself is designed to be platform-agnostic, meaning it doesn't assume you're using a browser or a specific rendering environment. For example:

React Native uses React but not ReactDOM because it renders components to mobile platforms instead of the browser.

Building a “Hello World” program in React:-
const heading = React.createElement("h1", {}, "Hello World From React!");
The empty {} in the React.createElement function call is the props object, used to pass attributes or properties to the created React element.
React.createElement(type, props, ...children)
type
The type of the element you want to create.In this case, it's "h1", which creates an HTML <h1> tag.
Props
An object containing the attributes or properties for the element.These could include HTML attributes like id, className, style, or event handlers like onClick.
For Example:-
const heading = React.createElement("h1", { id: "title", className: "main-heading" }, "Hello World!");

A Costly Operation:-
Adding new nodes into the Dom and removing them is a costlier operation.All these framweworks like react,angular are trying to optimize this process.


Hello World Using React:-
-React needs to have a Root(div) to make all the dom manipulations.
-Creating a element is core thing of react whereas creating a root and doing DOM manipulation on it is work of
 ReactDOM.
const heading=React.createElement("h1",{},"Hello World From React!");
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(heading);
-Most expensive operation is adding something to a web page(i.e. manipulating the DOM) and all these js libraries
are trying to optimize this.
-the object litereal inside the React.createElement ({}) is used to give attributes.
For Example:-{className:"heading"} Its Like key:value pairs canbe separated with a comma.

What are React Elements?
-React elements are normal javascipt objects.
-This object has props which are attributes and children we pass in {} inside createElement.
-console.log(heading) returns a object to you.
-root.render() converts the heading object and converts it in a html tag.

Mess:-
-Creating multiple nested elements using React.createELement will create a mess(un-readable code).
-So there exists something called as JSX.

Root:-
-React works only works inside a div(root).
-In the html file,anything we write above or below that root div will also be displayed on the page.
-Anything you write inside root div in the html file will be overwritten by react.

Why is React a library:-
-React can be injected in a small part of a entire codebase.
-React can be used omly for header or footer.It is small in size and compact.
-Like it works only inside the root div.
-React is at the end javascript which provides helper functions to develop a application.
-In react,order of files matter a lot.

Can React Itself Do All The Stuff Required To Build A Production Ready App?
-React being a small library cant do all the stuff.
-There is a lot off libraries,packages required to run a production ready code.

Intro To NPM:-
-NPM is node package manager.
-NPM manages packages

What is package.json?
-It is a configuration for npm.
-By configuring,we can download packages(dependencies) for our project.

Most Important Package In Our Project?
-Most important package in a project is bundler.
-When we have normal html,css and js file our whole code needs to be bundled together,compressed,minified,optimized,
cleaned before it is sent to production.eg.vite,parcel,vite etc.
-Parcel is a bundler which we are going to use.

Types of dependencies:-
-There are two types of dependencies dev and normal.
-dev dependency is required in a development phase.
-normal dependencies are used in production also.

what is ^ and ~ before the version number inside package.json file?

~version “Approximately equivalent to version”, will automatically update you to all future patch versions that 
are backwards-compatible, without incrementing the minor version. ~1.2.3 will use releases from 1.2.3 to < 1.3.0.

^version “Compatible with version”, will automatically update you to all future minor/patch versions that are
backwards-compatible, without incrementing the major version. ^1.2.3 will use releases from 1.2.3 to < 2.0.0.

Difference between package.json and package-lock.json :-

Purpose:

package.json: This file is primarily used for managing and documenting metadata about the project, including its 
name, version, author, dependencies, scripts, and other configuration details. It acts as a manifest for the project.

package-lock.json: This file is generated and updated automatically by npm when installing or updating packages.
 It is used to lock the exact versions of dependencies installed in the project, ensuring reproducibility and 
consistent installations across different environments.

Dependency Specification:

package.json: It contains the list of dependencies required for the project, along with their desired version 
ranges specified using semantic versioning or specific version numbers.

package-lock.json: It includes the specific resolved versions of all the dependencies, their sub-dependencies, 
and their exact installation locations. It acts as a snapshot of the dependency tree for ensuring consistent installations.

Version Control:

package.json: It is typically tracked in version control systems like Git and serves as a shared configuration 
file among project contributors.

package-lock.json: It is also tracked in version control systems to ensure consistent dependency installations a
cross different development environments.

Manual Editing:

package.json: Developers manually edit this file to add or remove dependencies, modify scripts, update version 
ranges, or make other configuration changes.

package-lock.json: It is generally not meant to be manually edited, as it is managed automatically by npm.
 Manual changes to this file can lead to inconsistencies or conflicts in dependency resolution.

what are node_modules?
-Node Modules contains all the downloaded packages(dependepncies).
-All the folders inside node_modules are dependencies and dependencies of dependencies.
-If you have package.json and package-lock.json you can re-download all the packages which are inside node_modules.

can you create a word file of it.Make it colorful ,with proper titles

Running our app:-
-Just like we have npm,similarly we have npx.
-npm means managing(downloading) a package where as npx means executing a package.
-npx package_name will execute the parcel.
-npx parcel index.html will run the file on a server.ALso if we update code it will automatically refresh.
-THis cool thing is done by parcel.

Is CDN a good way to bring react to our project?
-Fetching react every time using a cdn is costly operation instead we can have react in our node
modules.

The Import KeyWord:-
-Earlier we were bringing react into our project from a CDN.
-After installing react and react-dom from npm,to use it in our App.js file we have to import it from our node_modules.
-we use import React from "react"; and import ReactDOM from "react-dom/client"; to import them.
-Remember to add /client while importing react-dom.

When you run.You will get error as browser scripts cannot have imports or exports.
Solution:-
<script src="./App.js"></script>

it would treat App.js as a normal js file but it contains react code.Normal js files does not have imports or exports.
so we change the code to
<script type="module" src="./App.js"></script>

What all things is parcel doing?
-Dev Build
-Local Server
-HMR-Hot Module Replacement:-
Hot Module Replacement (HMR) is a feature in module bundlers like Parcel that allows modules to be updated in a running application without requiring a full reload.
-File Watching Algorithm(Written in C++)
-Faster Builds because of caching inside .parcel-cache folder
-Consistent hashing
-Code Splitting :-
	Loads only the necessary parts of the application, improving load times.
-Different Dev and Production Bundle
-Differential Bundling:-
	Makes our app support older browsers as well like internet explorer etc.
-Error Handling(Diagnostics)
-Image Optimization :-
	Automatic Image Compression: Parcel can automatically compress images to reduce their file size without significant loss of quality. This is done using various image optimization techniques and libraries.
Format Conversion: Parcel can convert images to more efficient formats like WebP, which offers better compression rates compared to traditional formats like JPEG and PNG.
Responsive Images: Although not directly a feature of Parcel, it can work with plugins and configurations to serve responsive images, optimizing images based on device characteristics.
-Minification of file:-
	JavaScript and CSS Minification: Parcel automatically minifies JavaScript and CSS files in production builds. This involves removing unnecessary whitespace, comments, and other non-essential elements to reduce file size.
Tree Shaking: Parcel performs tree shaking, which eliminates unused code from the final bundle, further reducing the size of JavaScript files.
Source Maps: Even after minification, Parcel can generate source maps, which help in debugging by mapping the minified code back to the original source code.

What are Source Maps?
-Source maps are a powerful tool in web development that help bridge the gap between minified or transpiled code and the original source code. They are particularly useful for debugging and understanding code that has been transformed for production.

What is Tree Shaking:-
Tree shaking is a technique used in JavaScript bundlers to optimize code by eliminating unused or "dead" code from the final bundle. This process helps reduce the size of the JavaScript files that are delivered to the client, improving load times and overall performance.

What is Tree Shaking?
Dead Code Elimination: Tree shaking analyzes the dependency graph of a JavaScript application to determine which parts of the code are actually used and which are not. It then removes the unused code from the final bundle.

Static Analysis: Tree shaking relies on static analysis of the code, meaning it examines the code structure without executing it. This is typically done during the build process.

ES6 Modules: Tree shaking works best with ES6 module syntax (import and export) because it allows for static analysis of the dependency graph. CommonJS modules (require and module.exports) are more challenging to analyze statically.


***Remove the line "main":"App.js" from package.json because it creates consflicst while executing index.html using npx parcel index.html

WHat is dist folder?
-When you do npx parcel index.html it builds a development build of your project hosted on localhost:1234

What is BrowsersList?
-Browsers list is a npm package used to configure our project to support for browsers.

What are Transitive Dependencies?
-Transitive dependencies are dependepcies of direct dependencies.

The Command npx parcel index.html :-
-npx meaing node package execute <package_name> which is parcel in this case where source file is index.html

What are scripts inside package.json file?
-scripts are industry level commands which are used to execute the project or run the project.
"scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html",
    "test": "echo \"Error: no test specified\" && exit 1"
  }

What is a React Element?
-Just like HTML element are DOM elements.
-React elements are javascript objects.
React.createElement => React Element => Object => HTML Element(after we render it on DOM)

JSX:-
const heading = React.createElement("h1", { id: "heading" }, "Hello World");
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(heading);

-Creating a element like above is very much lengthy and not readable.
-So,react devs created JSX.
-JSX is a javascipt syntax which is easier to create react elements.
-JSX is not part of react.React is different and JSX is different.
-React can be written without JSX.
-But,JSX makes devs life easy.
-JSX is a kind of convention where we merge HTML and JS together.
-JSX is not HTML inside Javascript.
-JSX is a HTML like syntax or XML(eXtensible Markup Language) like syntax.
-JSX is javascript XML.

Same code using JSX:-
const jsxHeading = <h1>Hello world from JSX</h1>;
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(jsxHeading);

if we log jsxHeading it is also a object only which is a same thing.

Does the Javascipt Engine understand JSX?
-No,the JS Engine doesn't understand the JSX code and will throw a error.
-The JSX code is first transpiled by the bundler(parcel in our case) before it is sent to the 
JS engine.
-Transpiled in a way that is understood by JS engine.

Is the transpilation done by parcel itself?
-No,Parcel is like a manager.It has some dependencies like babel.
-This transpilation part is done by babel.
-Babel is a JavaScript compiler or transpiler.

What is going on Behind The Scenes?
JSX =>React.createElement => JS Object => HTML Element

-JSX behind the scenes is React.createELement.
-Babel converts the JSX to React.createElement which is understood by react and then it is 
converted to JS Object. (visit https://babeljs.io/)

Slight difference between jsx and html :-
-class in className in JSX.

Multiple Lines:-
if we want to write a long text we wrap it inside paranthesis.
const heading=(<h1>Hello world
from Raj</h2>)

Extensions to use:-
1)Prettier
2)Bracket Pair COlorizer Toggler
3)ESlint
4)Better Comments

React Components:-
-Everything is a component in react.eg.button,searchbar etc.
-There are two Types of components:-
	1)Class Based Components(Old Way)
	2)Functional Components(New Way)

What is a react functional component?
-It is just a javascript function.
-Name should always start with a capital letter.
-Functional component is a function which returns a JSX code.
-const headingComponent = () => <h1 id="notHello">Hello world from JSX</h1>;
-***A functional component doesn't always has to have a explicit return keyword.
-Below are two ways of writing a react component:-

const HeadingComponent = () => <h1 id="notHello">Hello world from JSX</h1>;

const HeadingComponent2 = () => {
  return <h1>Hello World From Another Syntax</h1>;
};

-Below is a react element just to see the difference between a component and a element:-
const heading=<h1>Hello WOlrd</h1>

How to render a React Component on root?
root.render(HeadingComponent) Wrong!!
root.render(<HeadingComponent/>) Correct!!
-It is like a self closing html tag.
-THis is the syntax that babel understands.
-Passing multiple components to render :-
root.render([<HeadingComponent />, <HeadingComponent2 />]);

How to use a react component inside another component?
const Title = () => <h1 id="title">Welcome To React!</h1>;

const HeadingComponent = () => (
  <div id="heading">
    <Title />
    <p>This is Interesting!</p>
  </div>
);

-This is called Component Composition(Putting a component inside another component).

The use of curly paranthesis:-
-***You can run any JavaScript code inside a paranthesis.
const Title = () => <h1 id="title">Welcome To React!</h1>;
const num = 95;
const HeadingComponent = ({ num }) => (
  <div id="heading">
    <Title />
    {retSom({ num })}
    <p>This is Interesting!</p>
  </div>
);
root.render(<HeadingComponent num={num} />);

Some JS Revision about when to use paranthesis:-
function greet() {
  return "Hello!";
}

// Calling the function
console.log(greet()); // Outputs: "Hello!"

// Referencing the function
const sayHello = greet;
console.log(sayHello); // Outputs: [Function: greet]
console.log(sayHello()); // Outputs: "Hello!"

Compositions:-
-We can add a component inside component,a component inside element and vice versa.

JSX and Cross site scripting attacks:-
Any code you write inside {} lets say a API call,then it will be sanitized first by JSX preventing from CSS attacks.

A different way to add a react component inside another component:-
-It is like a function call inside object literals.
const HeadingComponent = ({ num }) => (
  <div id="heading">
    {/* <Title /> */}
    {Title()}
    {retSom({ num })}
    <p>This is Interesting!</p>
  </div>
);

Building our first app:-
1)Name Your Project (FoodZen)
2)Build a dummy UI on ms paint.
3)Low level Plan(How the components should look like).
	-Header
		*Logo
		*Nav-items
		*Add-to-cart logo
	-Body
		*Search Bar
		*Restaurent Container
			#Restaurent Card
				+IMG
				+Name
				+Star Rating
				+Cuisine
				+Delivery Time
	-Footer
		*Copyright 
		*Links
		*Contact Info


Commands To Set-Up A Project:-
-npm init
-npm install -d parcel
-npm install react react-dom

Props:-
-Props is a short form for properties.
-To pass data to a component dynamically we use props.
-Props are just normal arguments to a function.
-Passing a prop to a component is same as passing a argument to a function.

For Example:-
const Card = (props) => {
  console.log(props);
  return (
    <div className="resto-card">
      <img
        className="resto-img"
        src="https://media-assets.swiggy.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_660/gp1ityra6utvzqn6ghnv"
      ></img>
      <h3 className="resto-name">{props.restoName}</h3>
      <h4 className="cuisine-name">{props.cuisineName}</h4>
      <h4 className="star-rating">4.4 Stars</h4>
      <h4 className="delivery-time">38 minutes</h4>
    </div>
  );
};

-We can also do destructuring on the fly :-

const Card = ({restoName,cuisineName}) => {
  console.log(props);
  return (
    <div className="resto-card">
      <img
        className="resto-img"
        src="https://media-assets.swiggy.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_660/gp1ityra6utvzqn6ghnv"
      ></img>
      <h3 className="resto-name">{restoName}</h3>
      <h4 className="cuisine-name">{cuisineName}</h4>
      <h4 className="star-rating">4.4 Stars</h4>
      <h4 className="delivery-time">38 minutes</h4>
    </div>
  );
};
-This is just object destructuring.

Destructuring of props:-
-We destructure on the basis of keys.
For Example:-
<Card resData={responseObj} />

const Card = (props) => {
  // const { resData } = props; // this is destructuring on the basis of key(key is prop key(resData))

-we can also destructure on the parameter
const Card = ({resData}) => {

What if we dont want to destructure and access values directly from props?
-We follow this convention:-
 props.keyname.fieldsinsideobject

-For Example:-
<h3 className="resto-name">{props.resData.info.name}</h3>

Cuisines the array:-
If the api response object has a array of strings just use the join method.
join Method: The join method takes an array and concatenates its elements into a string, with the specified separator (in this case, ", ").

Optional Chaining for API responses:-

<h3 className="resto-name">{resData.info.name}</h3>
      <h4 className="cuisine-name">{cuisineString}</h4>
      <h4 className="star-rating">{resData.info.avgRating} stars</h4>
      <h4 className="delivery-time">{resData.info.costForTwo}</h4>
      <h4 className="delivery-time">{resData.info.sla.deliveryTime} mins</h4>

The above code looks very ugly because of resdata.info.avgRating.
Makes a code barely readable due to the dots.

Below is the code for optional chaining (includes a "?" mark)

const {name,avgRating,costForTwo}=resData?.info;

The question mark in your code snippet is part of the optional chaining operator in JavaScript. This operator allows you to safely access deeply nested properties of an object without having to explicitly check each level for null or undefined values.

Here's what it does:

The expression resData?.info checks if resData is not null or undefined before attempting to access the info property. If resData is null or undefined, the entire expression evaluates to undefined, and no error is thrown.

Key is react:-
-Whenever we are iterating onto something like using  a map function,each value should be denoted with a unique key.

Why give a key?
-Remember a tree like diagram?
-Lets say there is a parent node called container and it has 4 child nodes called card each.
-If we want to add a new card on the first place or somewhere in between then react doesn't know which card is newly added,so what react does it it clears the container where it rendered all the previous cards and renders all the cards with a newly added card .
-To prevent this from happening we give unique key to every card so that react can keep track of the cards and if a new card is added,react knows which card is added and renders only that card.
-This is all because of the render cycle of react.Adding key will help in optimizing the app.

The second parameter to the function which is returned by the map function is index. We can give this index as the key rather than giving keys manually.

for example:-
{responseList.map((restaurant,index) => (
          <Card key={index} resData={restaurant} />
        ))}
        
***But reacts official documentation says that never user indexes as the key.
***index as a key is anti-pattern(because the order might change but if order changes index doesn't change).
https://robinpokorny.com/blog/index-as-a-key-is-an-anti-pattern/

-Use shorted generater in backend to send keys

Modularizing code in different Files:-
-Remember to first export the component before importing in the mail file.
-WHile importing use full file name with extention.For eg.
import ReactDOM from "react-dom/client";
import Header from "./components/Header.js";
import Card from "./components/Card.js";

-Also never keep hardcoded URLs,objects inside components folder or dont hard code things.Add them inside the utils folder so that you can use them all over the app.

All About Exports and Imports:-

-When you have just 1 thing to import you use export default component_name or constant_name;
-when you have multiple things to import you use export {component_name,constant_name};

Also

-While importing,if the component or constant is exported by default you just import it like:-
import component_name from "./component_name.js"
-When you export multiple things,you use :-
import {component_name} from "./component_name.js";

-All this is about default export and named export.

Why Use Curly Braces {} for Named Exports?
Curly braces are used to destructure the exported object. When you export multiple things using named exports, they are essentially properties of an object.
This means that when you import them, you are specifying which properties (or named exports) you want to import from that module.
Does React Send an Object Out?
When you perform a named export, the module exports an object where each property corresponds to one of the named exports.
The curly braces in the import statement are used to destructure this object to access specific exports.
This approach provides flexibility and clarity, allowing you to import only the parts of a module that you need, which can improve code readability and efficiency.


-You can also use both in the same file like below:-

export const LOGO_URL =
  "https://www.citypng.com/public/uploads/preview/fast-food-delivery-cartoon-character-logo-hd-transparent-png-735811696674987bnjkeubewg.png";

const CDN_URL = "https://media-assets.swiggy.com/swiggy/image/upload/";

export default LOGO_URL;
export { CDN_URL };

import LOGO_URL from "file-path";
import {CDN_URL} from "file-path";

Creating A Button:-
<button>
      <span>Button</span>
    </button>
why to wrap the name of button inside of a span ?
-Helps in styling and more granular code

Proper way to pass props:-
-When passing a prop like btnName to a React component, you should consider the type of data you want to pass.
<Button btnName="Search" />

-Using Curly Braces: If you want to pass a variable or an expression that evaluates to a string, you should use curly braces:
const buttonName = "Search";
<Button btnName={buttonName} />

What makes a component re-render and does local variables affect them?

The issue with the "Top Rated Restaurants" button not working as expected is due to the way listOfRestaurants is being manipulated. In your current code, when you click the button, listOfRestaurants is being filtered, but this change is not reflected in the component's state or re-rendered because listOfRestaurants is a local variable inside the Body component. React does not automatically re-render components when local variables change; it only re-renders when state or props change.

To fix this, you should use React's useState hook to manage listOfRestaurants as a state variable.

***Hooks In React:-

-A react hook is a normal javascript function which is given to us by react.It is pre-built.
-This function is a utility function given by react and has some logic written behind it.
-There are two very important hooks:-
	1)useState():-Use state is to create state variable.
		-A local state variable's scope is inside the component.
		-When you make "useState()" function call,it will return a state variable.We 
		 receive it inside a array.
		-Whatever arguement we pass in the useState(0) call,it becomes the default 		 value.
*******Remember,always use state variable inside of a component only.Otherwise it wont run.

What is behind the scenes of useState Hook:-
useState is like array destructuring

const [resList,setResList]=arr;

same as

const resList=arr[0]
const setResList=arr[1]

  let [listOfRestaurants, setListOfRestaurants] = useState(responseList);
The above line is just destructuring a array on the go or on the fly.

-Destructuing is extracting elements of arr in resList and setResList.

Meaning of destructuring:-
-extracting elements of a array or a object.

Example use of useState:-
let [listOfRestaurants,setListOfRestaurants] = useState(responseList);
-here the first arguement is the state variable returned by the useState() function call and second arguement is a function which is used to update the state variable.

-Whenever a state variable changes,react re-renders the component.
-React is only good at DOM operations.This is what it aims,to optimize dom operations.

	2)useEffect()
-If we want to use react hooks we have to import them from "react" as named imports {useState}.


React Reconciliation Algorithm(Also Known As React Fiber):-


-Lets say we have a restaurant-container which has 10 restaurant-cards in it.
-Now What react does is creates a virtual DOM(document object model) of page or UI.
-The actual DOM meaning:-
	<div>
		<div>
			<img>
this is the actual DOM with HTML tags.
-Whereas a virtual dom is madeup of react elements.If we print a react element it prints a javascript object.SO,this virtual dom is nothing but a set of normal javascript objects.
-Virtual DOM is not the actual DOM but a representation of a actual DOM.

The Diff Algorithm:-
-Now lets say the restaurant-container which had 10 cards is now filtered out with a filter function and now has 3 cards.So a new Virtual DOM is created.
-The diff algorithm tries finds out the difference between 2 virtual DOM's(the previous dom with 10 cards and the new dom with 3 cards)
-After finding out,it will calculate the difference and then actually update the DOM on every render cycle.
-It is like git diff.
-THis algorithm tries to find out difference between old object and new object and then actually updates the DOM.
-Virtual DOM existed before react.It was just javascirpt representation on HTML DOM.
-So,taking the example of useState,the function used to update the state variable,when it is called,react starts all the reconciliation,diffing algorithm,re-rendering.
-THis algorithm has come up in React 16.

More About React FIbre Architechture:-https://github.com/acdlite/react-fiber-architecture

-React Fiber is reacts core algorithm.

Why is React Fast:-
-React is doing efficient dom manipulation.It does it through virtual DOM.
-It has a efficient diff algorithm which makes it fast.
-Incremental rendering:-ability to split rendering work into chunks and spread out over multiple frames.


Monolith and Microservice Architechture:-

-Previously apps were built using monolith architechture.
-Lets say a project which has everything inside it for eg. Code for API's,Code of UI,COde of Authentication,COde for database connectivity,Code for notifications(sms) etc everything in a single project.
-So,even if we have to change color of a single component,we have to build,compile and deploy entire project again with all this bulky code.
-Now,in todays time world is moving towards microservice architechture.
-In the microservice architechture,we have different services for different job.
-we have a a database connectivity service,we have a different authentication service,we have a different UI project , we have a service for our sms sending.So there are different services,and are called microservices.
-So,all these services combined together forms a big app.
-All these microservices talk to each other depending upon use cases.
-For each and every small thing we have a different project and this is called separation of concerns and single responsibility principle.Each service has its own job and no one is interfering.

How do these microservices talk with each other:-
-All these services run own there own specific ports.They are all deployed on their own specific ports.
-Now ,if UI wants to connect with backend,UI will call the Backend URL.
for eg. UI is deployed on www.foodzen.com/ then it will make a call to backend on www.foodzen.com/api

Question is how to make the api calls?

Approach 1:

As soon as the page loads => Make A Api Call => Render The Page

-Suppose the API takes 500ms,we wait for 500 ms and then render the page.

Approach 2:

Load the page => Render the page(skeleton) => Make the API call => Re-render the UI on the basis of data.

In React,we always follow second approach because it gives us the better user experience.

Making The API calls And The useEffect() Hook:-

-useEffect takes 2 arguements.
1)Callback Function
2)Dependency Array

useEffect(()=>{
  console.log("useEffect callled");
},[]);

-If we write the useEffect like this inside a component,the component will load and as soon as the render cycle completes the function inside the useEffect hook will be called.
-If you want to do something after the rendering of the component we use useEffect().
-Remember to perform the dev tools debugging with useEffect EP06 time 26:05 mins.
-While calling the API you will get ×
Unhandled Rejection (TypeError): Failed to fetch
Error.
-This error is because of CORS(cross-origin resource sharing) policy.
-Our browsers prevent or block us from making calls from one origin to another due to cors policy.


Something Imp about map ad filter:-
In JavaScript, when using arrow functions, you can omit the return keyword and the curly braces if the function body consists of a single expression. This is known as an implicit return.

Swiggy API and Config Driven UI:-
-It is industry level practice followed by major companies.
-The UI is driven by config which we receive from the backend.
-That means we have writtem the UI once and according to the data(the config) which i am getting from backend the data is getting changed.This is called config driven UI.
For eg.There can be a carousal(a card) which says 50% off on chinese food.Now this carousal is only available for people from mumbai and not from bangalore.
-So the UI shows the carousal onlyu when the data comes from the config.
-This is the latest practice that industry follows to write the UI once and it changes according to the data that comes from the backend.
-Another example is say there is lohri in punjab so the UI shows blue color,there is makar sankranti in maharashtra then the UI shows green color.So these color comes from the data which is received from the backend.And the UI is driven by the data received.This concept is called config driven UI.

The Swiggy API:-
Lazy Loading or Pagination: It's possible that the API implements lazy loading or pagination, meaning it only sends a subset of data initially, and more data is loaded as the user scrolls or interacts with the page. This is often referred to as "infinite scrolling" or "lazy loading.

-Swiggys API has a propery in their api(data.pageOffset.nextOffset) which has a key.This makes the cards on the page load slowly as we scroll.This is called pagination.
-Also,there are multiple cards that has restaurant array but 1 card has restaurant array which has 8 objects.
-So,we have to iterate over it to find that card.

Shimmer UI:-
-Showing the depiction or a fake skeleton of the actual UI before the page loads is called shimmer UI.
-Where do we add shimmer AI?
-Before the return(jsx),after the api call.

How does shimmer UI work?
-Since we are calling the fetch() function inside of useEffect hook first the page renders with shimmer ui and basic skeleton.
-Then the API is called and data is filled in.So we have to return shimmer component on the basis of below if condition

 if (listOfRestaurants.length === 0) {
    return <Shimmer />;
  }

This shimmer UI is just an example of conditional rendering.

You must use the ternary operator

return listOfRestaurants.length === 0 ? <Shimmer/> : <Body/>.


Creating the Login/Logout Button:-
-Remember react only re-renders a element or component if the props changes or the state changes so we have to use a state variable meaning useState.

onClick={() =>
              setLoginState((prevState) =>
                prevState === "login" ? "logout" : "login",
              )
            }

-The login button is inside header component.
-Since we are changing the content of the login button does just the login button re-render?
-No.The whole header component re-renders.

const [loginState, setLoginState] = useState("Login");

how does the loginState changes its value even after being a const variable?
-In this case,react renders the component.
-Now if we click on the login button,it changes to logout but but but the header component the whole is rerendered and the loginState variable is a whole new variable.
-So,react is not changing the value of loginState variable,it is re-rendering the entire component and along with it,it sets the new variable loginState's value as logout.

Why does everything in react/javascript has callback functions like onCLick?
-If we directly call a function in onClick={function()},the function will be called as the line of the code is ran.
-But we want to execute that function when we click on the button.
-This is why we use callback functions.

Coding The Search Box:-

<input
          className="search-field"
          type="text"
          placeholder="Search" value={searchText}
        ></input>
        <button className="btn" onClick={()=>{
            setSearchText(searchText);
        }}>
-The above code will not allow the user to enter anything in the search box.
Why is that?
-This is happening because the search field is binded to the state variable.
-So,we are trying to change the input field,but the state variable isnt changing,so we are not able to write anything in the input box.
-So,Input box is bind to state variable(searchText) and the default value given for searchText is "" so the input box wont change
unless the state variable(searchText is changed);
-So,as soon as the input changes we have to update the searchText(state variable).

<input
          className="search-field"
          type="text"
          placeholder="Search" value={searchText} onChange={(e)=>{
            setSearchText(e.target.value);
          }}
        ></input>
        <button className="btn" onClick={()=>{
            console.log(searchText);
        }}>
          <span className="btn-name">Search</span>
        </button>

        e represents the event triggered by the onChange event of the input field. This event object contains information about the event, including the target element that triggered the event.

-On every key press,the whole Body component is getting re-rendered.
-Whenever the state variable changes,react triggers the reconciliation cycle(re-rendering)
-Virtual DOM is the object representation of actual DOM.
-Below is the complete code for search bar filtering:-

<input
          className="search-field"
          type="text"
          placeholder="Search" value={searchText} onChange={(e)=>{
            setSearchText(e.target.value);
          }}
        ></input>
        <button className="btn" onClick={()=>{
            const searchedRestaurant=listOfRestaurants.filter((res)=>{
              return res.info.name.includes(searchText);
        })
            if(searchText===""){
              fetchData();
            }
            else{
              setListOfRestaurants(searchedRestaurant);
            }
            
        }}>
          <span className="btn-name">Search</span>
        </button>


-For the filter or map method if we use {} after the arrow function we must write return keyword.
-If we dont write any {} then we can ommit the return keyword. 
-Filter method returns array.

Also remember to convert both the strings to loswer case

***return res.info.name.toLowerCase().includes(searchText.toLowerCase());

All About useEffect Hook:-
-useEffect hook takes two arguements:-
1)callBack Funtion
2)dependency array
-useEffect hook is called after everytime my component renders.
-But,the dependency array changes the behaviour of the hook.
-But,having a dependency array isnt mandatory.
-If we dont have a dependency array,the useEffect hook will be called everytime the componenet renders.
useEffect(()=>{
  console.log("useEffect callled");
});
-If we have a empty dependency array then the hook will be called only on the initial render(only once).
useEffect(()=>{
  console.log("useEffect callled");
},[]);
-If we put something inside the dependency array,it is only called when the dependency changes.
useEffect(()=>{
  console.log("useEffect callled");
},[loginState]);
-Every time the loginState changes the useEFfect hook will be called.
-****No matter what,useEFfect will always be called after the initial render(only once after the component renders).

All About useState:-
-ALways write useState inside the component.
-ALways write useState at the top of the component code.
-Never use a useState hook inside if else or inside a loop or a function.They are only meant to be created inside of a functional component.This can create inconsistencies in your app.

Routing In React:-
-We use react router dom for routing which is a npm library.
-npm install react-router-dom
-When we are seting up our routes,we do that in out main(App.js file).
-We import {createBrowserRouter} from 'react-router';
-Bellow the component is App.js we create a const variable appRouter=createBrowserRouter([{},{}]).
-createBrowserRouter here will contain a list of objects which has path,element inside it.

For example:-
const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
  },
  {
    path: "/about",
    element: <About />,
  },
  {
    path: "/contact",
    element: <Contact />,
  },
]);

How to render it on the page?
-the appRouter const variable which we made is a configuration.And We have to provide this configuration.

WHere do we provide it?
-we import {RouterProvider} from "react-router";
-This RouterProvider is a component itself.
-while passing AppLayout in root.render we pass it as below:-
root.render(<RouterProvider router={appRouter}/>)
-RouterProvider is a configHolder.

How do we write Errors manually:-
{
  path: "/",
  element: <AppLayout />,
  errorElement: <Error />,
}
-We can create a Error component and return it if the main component has a error.
-We can also use useRouteError hook
import {useRouteError} from "react-router";
-It is used to give more details about the error.Displays a better message.

Creating Children Routes:-
-Similar to path,element and errorElement,we can have a property as children which is a list.
const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
    children:[
      {
        path: "/about",
        element: <About />,
      },
      {
        path: "/contact",
        element: <Contact />,
      },
    ],
    errorElement: <Error />,
  },

]);

-This makes About and Contact the children of AppLayout.

If we want components to load according to the routes how do we do that?
-The react-router-dom provides us another component called Outlet:-
import {createBrowserRouter,RouterProvider,Outlet} from "react-router";

What does this Outlet Do?
-This is like a placeholder for the components which are changed according to the routes.
For example:-
const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
    children: [
      {
        path: "/",
        element: <Body />,
      },

      {
        path: "/about",
        element: <About />,
      },
      {
        path: "/contact",
        element: <Contact />,
      },
    ],
    errorElement: <Error />,
  },
]);

-In the above code,
1)if the path is "/" then <AppLayout/> (which contains the Header element) and <Body/> will be loaded.
2)if the path is "/about" then since the /about is child of <AppLayout> ,the <AppLayout/> and <About/> will be loaded.
3)Similarly for "/contact",<AppLayout/> and <Contact/> will loaded.

-THis is all done because the <Outlet/> component holds the place in which according to routes the components are filled in.

How to make that redirect functionality where we click on about us and we are redirected to "/about" route?

In HTML, the href attribute inside an anchor (<a>) tag specifies the URL of the page the link goes to. It stands for "Hypertext Reference."

-We make use of <a> anchor tag and href="/about"

***But But But,in react we dont use anchor tag and href because it refreshes the complete page.

Then how do we naviagte to a new page without reloading the whole page?
-We use <Link/> component
import {Link} from "react-router";

How do we use Link Tag?
<Link to="/about">About Us</Link>

What actuallu happens here?
-It just refreshes the components,just changes the components rather than refreshing the complete page.
-This is why react applications are called as Single Page Applications.
-So basically the AppLayout is our single Page and everything else is just interchanging those components on that single page itself.

VIMP)There are Two types of routing that you can have in your react application:-
1)Client Side Routing:-
-When we first time load the app,it already has code for all the components.
-and when we click on the aboutus tag,it just loads the component on the same page.
-We are not fetching a page,that is why it is called client side routing.
-Its just one page and conponents get interchanged.This is client side routing.
2)Server Side Routing:-
-We have our index.html,aboutus.html,contactus.html etc and when we click on the anchor tag "/aboutus.html",
it re-renders the page,sends a network call to that aboutus.html and fetches that aboutus.html,and renderes it on our page.
-This is how it used to be before the js frameworks were introduced.THis is called server side routing.

Dynamic Routing:-
-Dynamic routing meaning if we click on a restuarant name,we should be redirected to the information of that particular restaurnat.
-It is obvious that we cannot have multiple components for multiple restaurants.
-So,we pass a identifier in the path like below:-
{
  path: "/restaurants/:resId",
  element: <RestaurantMenu />,
}
-So,as the resId changes,the data on the page should change.


**Revise :-How do we make a api call?
-We use a async function and fetch function to fetch the api link.
-We convert that data in readable format using .json method(is also async)
const fetchData=async ()=>{
const data=await fetch();
const response=data.json();
console.log(response);
}

Why do we use optional chaining?
Avoid Errors: When accessing nested properties, if any level of the property chain is null or undefined, attempting to access further properties will result in a runtime error. Optional chaining prevents this by returning undefined instead of throwing an error.

Simplifies Code: Without optional chaining, you would need to write multiple checks to ensure each level of the object exists before accessing the next level. This can lead to verbose and hard-to-read code. Optional chaining simplifies this by allowing you to write concise and readable expressions.

Error I got before Destructuring Before The API Call:-

-If we are using Shimmer UI before our api call is made.And if we try to destructure the api response,it will give you the properties of the response are undefined(something like immediate in error).
-so,instead of using ternary operator,use if condition for shimmer first,then destructure,and then return the JSX code

How do we dynamically access the params (restaurant/:params(123)) in our code?
-import {useParams} from "react-router";
const params=useParams();
-if we console.log(params) it prints a  object with exact param we have in our url route.
-suppose we have url as swiggy.com/restaurant/123
-this it prints a object with a key and value 123.
-we can destructure on the fly.
const {resId} = useParams();

The Important thing for prop key:-
-key should always be given to the parent jsx element.
<Link key={restaurant?.info?.id} to={"/restaurants/"+restaurant?.info?.id}>
  <Card resData={restaurant} />
</Link>

Fact about the Link Tag:-
-behind the scenes <Link><Link/> is using anchor tag.
-Link is a wrapper over anchor tag.
-With the Link tag,react router is keeping track of this link.


Class Based Components:-
-Class based components is the older way of writing components in react.
-Similar to functional component is a normal javascript function,Class based components are normal javascript classes.
-Functional component are normal javascript function which return some jsx.
-Class based components are normal javascript classes which extends React.Component class and which has a render method which 
returns some JSX.

class UserClass extends React.Component {
  render() {
    return (
      <div className="user-card">
        <h2>Name</h2>
        <h3>Location</h3>
        <h4>Contact</h4>
      </div>
    );
  }
}

we have to import React from "react"; to use the React.Component class.
we can also destructure on the fly import {Component} from "react";


-extends is inheritance.Our made component is inheriting properties from React.Component class.
-This class based component having the jsx to return is converted into html and is displayed on the web page.

Constructor and super method inside a class based component?

constructor(props) {
  super(props);
  console.log(props);
}

Initializing Props Using React.Component's Constructor: By calling super(props), you are indeed passing the props to the constructor of React.Component. This is essential because React.Component sets up this.props with the values you passed. This setup allows your component to access the props using this.props throughout its lifecycle.

Creating an Object of MyComponent: When you instantiate MyComponent, you are creating a new object of MyComponent. Since MyComponent extends React.Component, it inherits all the functionalities of React.Component but also has its own properties and methods as defined in MyComponent.

Extending React.Component: By extending React.Component, MyComponent inherits its methods and properties. The super(props) call is crucial because it ensures that the part of the MyComponent object that is handled by React.Component is properly initialized.

Using the this Keyword: After calling super(props), the this keyword can be used within the constructor of MyComponent. It refers to the current instance of MyComponent. By setting this.props through super(props), you ensure that this.props in your component's constructor and other methods correctly reference the props passed to MyComponent.

It is same as

class MyComponent{
let name;
constructor(name){
this.name=name;
}
}
class MyComponent2 extends MyComponent{
constructor(name){
super(name);
console.log(this.name);
}
}

let newComponent=new MyComponent2("Raj");


How did we create state variables in a class based Component?
-Loading or rendering a functional component on our web page means a functional component which is a normal javascript function returning a piece of jsx.SO this is same as we are invoking the functions to return some jsx on our web page.
-Similarly,loding a class based component on our web page means creating a instace of the class.
-Whenever you create a instance of a class we call the constructor of a class.And this is the best place to receive props and this is the best place to create state varibales.

class UserClass extends React.Component {
constructor(props) {
  super(props);

  this.state = {
    count: 0,
  };
}

-Above is the code to write state variables.

-How do we use the count(state varibale)?
render() {
const { name, location, contact } = this.props;
const {count}=this.state;
return (
  <div className="user-card">
    <h1>{count}</h1>
    <h2>{name}</h2>
    <h3>{location}</h3>
    <h4>{contact}</h4>
  </div>
);

-This is similar to how we use props.

Behind the scenes of a functional component:-
-if we create two state variables
const [count]=useState(0);
const [count2]= useState(0);

-behind the scenes react is creating whole big single object of all state variables.
-similar to 
 { 
  count:0
  count2:0
 }

How do we update these state varibales?
-we use the this.setState() method.
The this.setState() method is part of the React.Component class, which is why you can use it directly in class-based components when you extend React.Component. You do not need to import setState separately; it is inherently available to any class component because of the inheritance from React.Component.

Here's how it works:

Inheritance: When you create a class component by extending React.Component, your component inherits all the methods and properties of React.Component, including setState.

State Management: setState is a built-in method provided by React to manage the component's state. It allows you to update the state and trigger a re-render of the component with the new state.

return (
      <div className="user-card">
        <h1>{count}</h1>
        <h2>{count2}</h2>
        <button onClick={()=>{
        this.setState({count:count+1,count2:count2+1});
        }}>Count Increase</button>
        <h2>{name}</h2>
        <h3>{location}</h3>
        <h4>{contact}</h4>
      </div>
    );
  }
}

-we can do multiple changes inside this.setState like in the above code.

-similarly we update the state in useState hook 

onClick={()=>{
setCount(count+1);
}}

-We can also have a function inside the setCount

setCount((prev)=>prev+1)

-If we have multiple state variables inside a component,react maintains a big object containing all the state variables.
-If we change the count(a state varibale among many others) only the count(state variable) is touched by reacted and other all are left untouched.

Class Based Component LifeCycles:-
-Loading the component means mounting the component on the webpage.
-Constructors are the first things which are called when we have a class based component.
-after constructor,the render(){} method is called.

-Similar to the render(){} method,we also have another method called as componentDidMount(){}
-In a class based component,first the constructor is called,then the render() method is called and then the componentDidMount(){} method is called.

contructor(){} => render(){} => componentDidMount(){}

But,what if we have a parent component(class based) and inside which a child component(class based).
just like

class About extends Component{
constructor(){

}
render(){
return (
<div>
<UserClass/>
</div>
)
}
}

and we have log statements inside parents constructor,render and componentDidMount method as well as childs 
 constructor,render and componentDidMount methods.Which will be called first?

 parent constructor => parent render => child constructor => child render => child componentDidMount => parent componentDidMount

 -This is because the parent component hasnt finished rendering yet,and in between has to render another component so the parents componentDidMount renders at the end.
 -This is the lifecycle of a parent child relationship.

 Use Case Of The Method componentDidMount(){} :-
 -making API calls similar to the useEffect hook.
 -React wants to quickly render the component,then make the api call and then fill up the page.
 -componentDidMount runs after the component is mounted on the dom tree.
 -This way we can prevent waiting for api to give data and then render the page.

 ***VIMP confusing case

 What happens if there are multiple child components inside a parent component?

 parents constructor => parents render => first childs constructor => first childs render => second childs constructor => second childs render => first childs componentDidMount => second childs componentDidMount => parents componentDidMount

 refer to the belowlink for react lifecycle diagram:-
 https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

 There are two phases in react lifecycle:-
 1)Render Phase:-
 -constructor is called
 -render() method is called
 2)Commit Phase
 -React actually updates the DOM
 -componentDidMount is called

***VVIMP - so basically to optimize while we have multiple children,the commit phase and render phase is batched together.
-react does this because DOM manipulation is the most expensive operation when we are loading up the page.

-in the reconciliation process we have seen the diffing algorithm which compares two virtual doms(objects) and finds out difference between them.
-This is done in the render phase.

-so react tries to batch up the render phase and actual dom update separately .
-this is why the optimization in :-
( What happens if there are multiple child components inside a parent component?

 parents constructor => parents render => first childs constructor => first childs render => second childs constructor => second childs render => first childs componentDidMount => second childs componentDidMount => parents componentDidMount )

Commit Phase:-
parents constructor           }
parents render                }Batching 
                              }of 
first childs constructor      }render
first childs render           }phase
                              }for
second childs constructor     }optimization
second childs render          }using react reconciliation

<Actual DOM manipulation happens in a single batch>
first childs componentDidMount      
second childs componentDidMount
parents componentDidMount

Is this the same for functional components?
-yes.
-In commit phase actual function is called which is returning the jsx
-Then React updates the dom
-The commit phase involves effects defined using hooks like useEffect, which run after the component has been rendered to the DOM.

Making A API call in componentDidMount :-

async componentDidMount(){
      const data=await fetch(GITHUB_API);
      const response=await data.json();
      console.log(response);
      this.setState({userInfo:response});
  }

-Since making a api call is a async operation,we make the componentDidMount function async itself.
-to access the data we can use destructuring

const {name,location,bio}=this.state.userInfo;

-and initialize the state variable as below

constructor(props) {
    super(props);
    this.state={
      userInfo : {
        name:"dummy name",
        location: "dummy location"
      }
    };
  }

-we can fill the default value as some dummy data.

***VVIMP How to test using a debugger?
-just write the keyword debugger; in your code and open browser it will automatically start a debugger.

-So here the lifecycle looks like
1)Constructor is called to initialize values of props and to setup state variables.}in commit phase
2)page is rendered }in commit phase
3)React updates the dom
4)API is called (componentDidMount)

***If you write anything after the return statement inside render method,the code becomes unreachable.

The concept of componentDidUpdate(){} :-
-After the api is called from componentDidMount
-THe this.setState is called to set the response form value as the value for state variable.
-When the state variable is updated , react calls the render method again with the new api updated data
-React updates the DOM
-componentDidUpdate is called;

The concept of componentWillUnmount(){} : -
-Mounting means showing or rendering on the UI.
-Where as unmounting means removing from the UI.
-This method will be only called when the component is entirely removed from the UI.
-Lets say for example if i move from aboutus page to contact us page,componentwillunmount will be called.

***Never compare class based components with functional components

**Important point for useEFfect hook:-
if we have two depndencies inside the dependency array
useEFfect(()=>{},[dep1,dep2])
-then even if either is changes,the useEffect is called
-If both dep1 and dep2 change at the same time, the useEffect hook will execute only once in that render cycle. React effectively batches the updates and applies them together, triggering the effect only once after all the state or props updates are processed. This ensures the effect runs after the component has rendered with the latest updates.

Previos problems and newer solutions:-
-if we want to do something if a state changes then we do
componentDidUpdate(prevProps,prevState){
if(prevState.count!== this.State.count){
console.log("do some stuff").
}
}
-even if we have multiple dependencies,we have separate if-else conditions for that.
-so react developed useEffect hook with a dependency array.

Cons of Single Page Applications:-
lets say we have something like 

componentDidMount(){
this.timer = setInterval(()=>{
console.log("Hello There!")
},1000)
}

-So basically,componentWillUnmount should be called only once after we change from one page(component) to other page(component).But it keeps on printing even if we change pages.
-If we revisit it,it starts another interval.Keeps on doibling and tripling.
-THis is a big con of single page applcations.

to fix this we also have to write clear interval inside componentWillUnmount

componentWillUnmount(){
clearInterval(this.timer);
}

same thing happens with useEffect also.

-This is the best example of if you are creating mess,then you have to clean it up also.

How do we handle this is useEffect ?
-useEffect also has a function like componentWillUnmount.

useEffect(()=>{
  const timer=setInterval(()=>{
    console.log("useEFfe t called");
  },1000);
  return ()=>{
    clearInterval(timer);
  }
},[]);

-we just have to return a function.Which is similar to componentWillUnmount.
-tells what do do after the component is unmounted.

Real life example of use case of component will unmount:-
lets say we have a setInterval inside of componentDidMount which calls a api .
-That api has a page offset.now you want to keep collecting the data but stop when we move to another page(another component) then here comes the use Of componentWillUnmount to clear the interval.

we can make componentDidMount async.but why cant we do with useEffect?

useEFfect(async()=>{},[])   ❌

-The useEffect hook in React is designed to run side effects in a functional component. It does not directly support making the function passed to it async, because useEffect expects a cleanup function or nothing to be returned, and an async function implicitly returns a promise.

However, you can still perform asynchronous operations inside a useEffect by defining an inner async function and calling it. Here's how you can do it:

useEffect(()=>{
const fetchData=async()=>{

}
fetchData();
})


***A VVIMP fact for useState()

-useState gives use two parts
1)stateVariable
2)A function to modify the stateVariable

-The function used to modify the stateVariable expects a value and not an expression

setState(prev=>[...prev,listItem]); ✓

setState(prev=>prev.concat(listItem));✓ This Works because concat method returns a new array with a concatenated value

setState(prev=> prev.push(listItem)) ❌ This doesnt work because we are trying to modify the exisitng array which will most probrably give you a error becasue firstly const const [state,setState] = useState([])
here state is a const variable that cannot be changed.
-and secondly react only compares two virtual doms or starts its reconciliation cycles when either a state variable changes or a prop changes.

Single Responsibility Principle:-
-Suppose you have a function,or you have a class or you have any identity of your code should have single responsibility.
-For example. header components work should be just displaying a header on our page,a restaurant card should only display a restaurant card on our page.
-The concept of modularity means breaking our code into different modules so that code becomes more maintaimable and more readable and testable.
-If we have a very big application and our restaurantcard has a bug then we can just apply test cases to our restaurant card and very easily find the bug.


Custom Hooks:-
-We can make hooks to api calls because at the end of the day hooks are just utility functions.
-while naming a hook always use "use" in the beginning.It will help react identify that it is a hook.
-Though,using the word "use" before the name of the hook is not mandatory,but recommended by react.Similar to component name
starting with a capital letter.
-While creating a custom hook,think of what it is getting input and what we are supposed to return from it.
-For example:- we take restaurantId as input and we return restaurantInfo by fetching the data from api.

How do we write a hook?
-same as a component.Just instead of returning jsx we return the api data or whatever is required.
const useRestaurantInfo = (resId) => {
  const [resInfo, setResInfo] = useState(null);
  console.log("useRestaurantInfo called");
  useEffect(() => {
    fetchMenu();
  }, []);

  const fetchMenu = async () => {
    const data = await fetch(MENU_API + resId);
    const response = await data.json();
    const card = response?.data?.cards[2]?.card?.card;
    setResInfo(card);
    console.log(card);
  };

  return resInfo;
};

export default useRestaurantInfo;

*****If a Body component has 2 hook calls,how is re-rendering done?
-First entire code is executed with both hooks and component itself.
-The api calls inside of them are asynchronous and so are independent.
-Lets say the data of first hook is received.
-Now again the entire component will re-render both hooks and body.
-Now,since everything including hooks is re-rendered,is the api again called?No,it depends on gthe implementation.Since we use api call inside useEffect and give it a empty dependency array,the is called only once.
-Now if the second api's data is received,again the entire component will be rendered.
-Since,the states inside of the hooks are changing,re-rendering(reconciliation is happening).

Creating a online/offline custom hook:-
import { useEffect, useState } from "react";

const useOnlineStatus = () => {
  const [onlineStatus, setOnlineStatus] = useState(true);
  useEffect(() => {
    window.addEventListener("offline", () => {
      setOnlineStatus(false);
    });
    window.addEventListener("online", () => {
      setOnlineStatus(true);
    });
  }, []);
  return onlineStatus;
};

export default useOnlineStatus;

The useEffect itself is not called again when the user goes offline or comes back online. Instead, the event listeners that were set up during the initial render handle these changes. The useEffect is only responsible for setting up these listeners once when the component mounts.
-So,when the useEffect is called once,both the event listeners are added.
-in the code,we add event listener to the global object which is the window object.
-From the event listener code we are telling that,if user if offline/online run this callback function.

Can we show online/offline status as green and red symbol?
-<li className="online-status">Online Status : {onlineStatus ? "🟢" : "🔴"}</li>


Implicit Global Variable Declaration:-
for (let i = 0; i < json.data.cards.length; i++) {
extractedData =
  json?.data?.cards[i]?.card?.card?.gridElements?.infoWithStyle
    ?.restaurants;

if (extractedData && extractedData.length === 8) {
  setListOfRestaurants(extractedData);
  setFilteredRestaurant(extractedData);
  console.log(extractedData);
}
-Here i have no where declared the extractedData varaible as let,const or var then to it works.
-this is because js implicitly makes it global variable.
-This can result in unintended behaviour.

Linters and Syntax:-
What are Linters?

A linter is a tool that analyzes code for potential errors, coding style violations, and best practices. It helps maintain clean, readable, and bug-free code by catching issues early.

Linters are used in various programming languages:

    JavaScript/TypeScript → ESLint
    Python → Pylint, Flake8
    C++ → Clang-Tidy
    CSS → Stylelint

What is ESLint?

ESLint is a linter specifically for JavaScript and TypeScript. It helps detect and fix:
✅ Syntax errors
✅ Coding style issues
✅ Unused variables
✅ Inconsistent formatting
✅ Potential bugs

-If we setup linter for react,and we dont use capital letter for a Component or "use" keyword for a hook,it would start throwing
error.
-This is a industry level practice.


Bundler Recap:-
-Bundlers main job is bundling the react code and giving out a single js file.
-It contains all the code for all the components.
-Your js file size increases by how many component it holds.
-the dev build of js file is larger than production build becasue the minification and optimization is not happened yet.
-You cant make a large scale production ready application if we dont take care of this.Our app will become slow.
-If we want to build a large scale app,we have to break our app down into smaller pieces.
-So,we have to make smaller bundles of the files.
-This process is known as chunking or code splitting or dynamic bundling or lazy loading or on demand loading,
dynamic import.

How do we do that?
-We bundle our code into logical bundles.By logical bundles,we mean that each bundle should have enough code for a single feature on the webpage.
-We just load the code on demand.React uses client side routing so all the code is received at the first go.But it would make the code bulky.So,few pages which are rarely visited we can lazily load.
-So,when we visit that page,then only we load it.

const Grocery=lazy(()=> import("./components/Grocery.js"));

-Instead of normally importing a component,we import it inside of a callback function inside the lazy method.
-lazy is a named import from "react" itself.
import {lazy} from "react";
-So,now our main bundle does not have code for the grocery component.It is completely different bundle.

-But,it can fail since it is lazily loading.And would take time to load and browser would show error screen.
-To fix this react gives us a component called Suspense.
import {Suspense} from "react";

and we wrap our component inside the suspense component

<Suspense><Grocery/></Suspense>

-But,Suspense takes a prop called fallback .This fallback is a placeholder which says load this until my lazily loaded component loads.
-Same like a Shimmer UI.

When do we use Code Splitting or dynamic bundling?
-When our app is bloating or taking a lot of time to load,that is when your bundle size has increased a lot.
-To fix this we have to use code splitting.

Different types of styiling:-
-Vanilla CSS
-SASS and SCSS
-Styled Components(used by uber)
-MUI,ChakraUI,ShadCN
-TailwindCss

Setting up Tailwind Css:-
https://tailwindcss.com/docs/installation/framework-guides/parcel

What is postcss?
-if we want to transform css inside of javascript,postcss is the tool to do that.

what is postcssrc file?
-it is a configuration for postcss
-Using this our project understands what is written inside tailwind.

Styling in tailwind css:-
-Tailwind css provides classnames to all the css you want to write inside your app.
-Adding global styling in index.css file

@layer base {
  * {
    @apply box-border m-0 p-0;
  }
  html{
    background-color: #ECECEC;
    min-height: 100vh;
  }
  body{
    background-color: #ECECEC;
    min-height: 100vh;
  }
}

-Global styling means this styling will be applied to all the components on the web page

-How to center a div?
-If we want to center a div,we have to give properties to the parent element.
-display:flex will get them all lined up horizontally.
-justify-content:center will center the div horizontally
-align-items:center will center the div vertically.

Re-styling Shimmer:-
{Array(8)
        .fill("")
        .map((_, index) => (
          <div
            key={index}
            className="w-full sm:w-1/2 md:w-1/3 lg:w-1/4 h-40 bg-gray-300 animate-pulse rounded-md mb-6"
          ></div>
        ))}

  Array(8) → Creates a new array with a length of 8.
.fill("") → Fills the array with empty strings (""). This ensures that we have a predefined length array to iterate over.
.map((_, index) => (...))

    This iterates over each element of the array.
    _ (underscore) is a throwaway variable, meaning we don’t care about the actual values inside the array, just the index.
    index is used as the unique key for each div.
    Each iteration returns a div that acts as a placeholder (shimmer effect).

The _ (underscore) we used here is because we always have some item to ierate upon,and we pass the first parameter as the item,
but since we are creating the array with the function Array(8),we dont have anything,so we are using the unserscore.

Hard coded values in tailwind:-
-If we want to give some hard coded values we can use square brackets
w-[10px] or bg-[#ECECEC]

Why use tailwind css:-
-Dont have to everytime switch to index.css file to give styling for every class-name.
-Not having a bulky css file.
-It is very dynamic,the css you use only that css code is put into your app.That means when parcel will bundle our web page it
will only include the css which is required on our web page.
-Helps in not having redundant css.

Relevant sections in Parcel Docs:

    Tree Shaking & Dead Code Elimination
    Parcel Docs - Tree Shaking

        "Parcel automatically eliminates unused JavaScript through tree shaking, reducing the size of your final bundle."

    CSS Modules Optimization
    Parcel Docs - CSS Modules

        "CSS modules only include styles that are imported in JavaScript files, avoiding unnecessary CSS."

Cons about tailwind:-
-Makes the code less readable.

Media Queries And Responsiveness:-
-sm is small meaning for mobile phones.
-if we do bg-blue-500 sm: bg-yellow-50 that means if it is small screen,bg color will change to yello,for large screen bg color
would remain blue.
-Similarly for md and lg.

Higher order components in React:-
-Higher order components are functions which takes component as a parameter and returns a component.
-It takes a existing component and enhances it,tweaks it a little and returns it back.
-Higher order component is a function,which returns a component which returns some jsx which includes some tweaks or changes.

How does a higher order component looks like?

export const withFlatDiscount = (Card)=>{
return (props)=>{
return (
<div>
<label>50 rs off</label?
<Card {...props}/>
</div>
);
}
}

-We pass props inside the function which is returned by the return keyword.
-While using the component which is received by paramter,if it expects some props,we should pass props using the spread operator.
- in React, props is an object.The spread operator (...) in JavaScript is used to unpack elements from an array or properties from an object.

How do we use the Higher order component?
-First we create a component out of it.
const CardWithFlatDiscount = withFlatDiscount(Card);
-Here CardWithFlatDiscount is a Higher Order Component.

<div>
  {filteredRestaurant.map((restaurant) => (
    <Link
    >
      {restaurant?.info?.aggregatedDiscountInfoV3 ? (
        <CardWithFlatDiscount resData={restaurant} />
      ) : (
        <Card resData={restaurant} />
      )}
    </Link>
  ))}
</div>

-Above is the code to use it by making sure to pass props which are needed for the component which is passed as a arguement.

Why do we pass props using ... spread operator?
-Higher order component are pure functions.
-Pure function means it will not modify the code of the component receives,it will not change the default behavior of the Card component it receives.
-We are just adding something on top of it.

***Can we pass some extra props to the higher order component?
-Yes.
-Can we use it inside the component which was sent as an argument?
-Yes,but only for the cards for which the condition is met.
Like we are using Higher order component for Discount,so out of all the cards which is passed to the original component,the discounted cards only can receive the extra props.

import { CDN_URL } from "../utils/constants";

const Card = (props) => {
  const { resData } = props;
  const { name, avgRating, costForTwo, sla } = resData?.info;
  const cuisines = resData.info.cuisines;
  const cuisineString = cuisines.join(", ");
  const imgLink = CDN_URL;

  return (
    <div className="border border-gray-300 rounded-lg p-2 shadow-md hover:shadow-lg transition min-h-100">
      <img
        className="w-full h-50 object-cover rounded-md"
        src={imgLink + resData.info.cloudinaryImageId}
        alt={name}
      />
      <h3 className="text-lg font-semibold mt-2">{name + props.nonConcern}</h3>
      <h4 className="text-gray-600">{cuisineString}</h4>
      <h4 className="text-yellow-500 font-medium">{avgRating} ⭐</h4>
      <h4 className="text-gray-700">{costForTwo}</h4>
      <h4 className="text-green-500">{sla.deliveryTime} mins</h4>
    </div>
  );
};
export const withFlatDiscount = (Card) => {
  return (props) => {
    const {nonConcern} = props;
    const { resData } = props;
    return resData?.info?.aggregatedDiscountInfoV3 ? (
      <div>
        <label>
          {resData?.info?.aggregatedDiscountInfoV3?.header + " ABOVE" + nonConcern}
        </label>
        <Card {...props} />
      </div>
    ) : (
      <div>
        <label></label>
      </div>
    );
  };
};

export default Card;

-Check for yourself in the above code,where we are writing the name.


How do we position the label over the card?
-we make the parent container as relative.

In Tailwind CSS, the properties for setting the position of an element relative to its closest positioned ancestor (usually set with relative, absolute, fixed, or sticky positioning) are controlled using the following classes for bottom, left, right, and top:

bottom-[value]
left-[value]
right-[value]
top-[value]

***Task:-
Create a todolist with setting status as high priority for some todo lists using HOC.


How to set a default image if img from cdn fails?
-use a event handler

onError={(e)=>{
  e.target.onerror=null;
  e.target.src=DEFAULT_IMG;
}}

When an image fails to load, the onError event fires. If we set a fallback image inside onError, but that fallback image 
also fails to load for some reason, the onError event will trigger again and again, leading to an infinite loop.

React rendering and Map iteration:-
-If we map through a array and return a component,everything will be loaded all in for once.
-this is because of how react does rendering.
-react iterates on map(prints logs which are equal to total items in that array) and after that calls the component the number of times the iterator is called.
-This happens once.Because react renders first,then updates the DOM.

Tailwind Divisions:-
-Tailwind divides our page into 12 divisions.
-So,if we do w-6/12 that means the component takes with of half the page.
-m-auto brings content in center.

What is accordion UI?
-In this UI we have a arrow which can expand and collapse the data inside it.
const [showItems, setShowItems] = useState(false);
{showItems && itemCards.map((item) => {
  const { id } = item?.card?.info;
  return <ItemList key={id} item={item} />;
})}

-ABove code is used to build a toggle feature.If both conditions true then show itemCards.
-Also,we can change icons with the same code
<h1 className="font-bold text-lg">{showItems ? "▲" : "▼"}</h1>






